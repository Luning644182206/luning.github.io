[{"title":"[前端日记][ES6日记] 字符串的扩展","url":"/2019/10/12/前端日记-ES6日记-字符串的扩展/","tags":["前端日记","ES6日记"]},{"title":"[前端日记][ES6日记] 变量的解构赋值","url":"/2019/10/10/前端日记-ES6日记-变量的解构赋值/","content":"    ES6的解构可以说是花式解构了，各种解构方式都可以，眼前一亮。\n# 数组的解构\n## 基本用法\n    赋值可以通过数组对应赋值。\n```javascript\n    let [a, b, c] = [1, 2, 3];\n    a; // 1\n    b; // 2\n    c; // 3\n```\n    也可以使用嵌套方式赋值\n```javascript\n    let [foo, [[bar],  baz]] = [1, [[2], 3]];\n    foo // 1\n    bar // 2\n    baz // 3\n\n    let [ , , thrid] = [\"foo\", \"bar\", \"baz\"];\n    thrid // \"baz\"\n\n    let [head, ...tail] = [1, 2, 3, 4];\n    head // 1\n    tail // [2, 3, 4]\n\n    // 补充...的作用\n    // console.log(...[1,2,3]);  // 1 2 3\n    // console.log(1, ...[2,3,4], 5); // 1 2 3 4 5\n    // console.log([1, ...[2,3,4], 5]); // [1, 2, 3, 4, 5]\n    // 所以这里可以用来替换数组的 concat 函数，以往我们合并数组，需要 var arr3 = arr1.concat(arr2), 如果使用扩展运算符:\n    // var arr3 = [...arr1, ...arr2];\n    // 在对象中的使用\n    // let obj1 = {a:1, b:2};\n    // let obj2 = {c:3,b:{e:4,f:5}};\n    // let obj3 = { ...obj1, ...obj2 }; \n    // console.log(obj3); // {a:1, b:{e:4,f:5}, c: 3}\n```\n    如果解析不成功，则变量值为undefined。\n```javascript\n    let [bar, foo] = [1];\n    bar // 1\n    foo // undefined\n```\n    存在不完全解构的情况，举例：\n```javascript\n    let [a, [b], d] = [1, [2, 3], 4];\n    a // 1\n    b // 2\n    d // 4\n\n    let [x, y] = [1, 2, 3];\n    x // 1\n    y // 2\n```\n    等号右边不是数组，或者不是可遍历的结构，那么久会报错，举例：\n```javascript\n    let [foo] = 1;\n    let [foo] = false;\n    let [foo] = NaN;\n    let [foo] = undefined;\n    let [foo] = null;\n    let [foo] = {};\n```\n    报错的原因是等号右边的值或是转为对象以后不具备Iterator接口（前五个），最后一个是本身就不具备Iterator接口\n    Set也可以使用数组的结构赋值，举例：\n```javascript\n    let [x, y, z] = new Set(['a', 'b', 'c']);\n    x // \"a\"\n    y // \"b\"\n    z // \"c\"\n```\n## 默认值\n    解构赋值允许使用默认值\n```javascript\n    let [foo = true] = [];\n    foo // true\n\n    let [x, y = 'b'] = ['a'];\n    x // 'a'\n    y // 'b'\n```\n# 对象赋值解构\n    解构对象，举例：\n```javascript\n    let { bar, foo, baz } = { foo: \"aaa\", bar: \"bbb\" };\n    foo // \"aaa\"\n    bar // \"bbb\"\n    baz // undefined\n```\n    上面的例子可以知道，对象解构不在乎顺序，变量名字与对象属性同名即可。不一致的情况举例：\n```javascript\n    let { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\n    baz // \"aaa\"\n    foo // error: foo is not defined(foo是匹配的模式，baz是变量)\n\n    let obj = { first: \"hello\", last: \"world\"};\n    let { first: f, last: l } = obj;\n    f // \"hello\"\n    l // \"world\"\n```\n    嵌套解构，举例：\n```javascript\n    let node = {\n        loc: {\n            start: {\n                line: 1,\n                column: 5\n            }\n        }\n    };\n\n    let {\n        loc,\n        loc: {\n            start\n        },\n        loc: {\n            start: {\n                line\n            }\n        }\n    } = node;\n    loc // object {start: Object}\n    start // object {line: 1, column: 5}\n```\n    对象解构也存在默认值\n```javascript\n    let {x = 3} = {};\n    x // 3\n\n    let {x: y = 3} = {};\n    y // 3\n```\n    已声明的变量解构\n```javascript\n    let x;\n    { x } = { x:1 };\n    // SyntaxError: syntax error\n\n    let x;\n    ({ x } = { x:1 }); // 正确\n```\n    对数组进行对象解构\n```javascript\n    let arr = [1, 2, 3];\n    let {0: first, [arr.length - 1]: last} = arr;\n    first // 1\n    last // 3\n```\n# 字符串解构赋值\n    字符串解构举例：\n```javascript\n    const [a, b, c, d, e] = \"hello\";\n    a // h\n    b // e\n    c // l\n    d // l\n    e // o\n\n    // 同样也可以使用对象的属性，如length属性\n    let {length: len} = \"hello\";\n    len // 5\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端日记","ES6日记"]},{"title":"[前端日记][基础日记] 基本概念","url":"/2019/09/25/前端日记-基础日记-基本概念/","content":"# 关键字和保留字:\nECMA-262描述了有一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或者结束，或者用于执行特定操作等。按照规则，关键字也是保留语言保留的，不能用作标识符，以下是ECMAScript的全部关键字：\n\n| break    | do       | instanceof | typeof     |\n| --------   | -----  | ----- | -------- |\n| case     | else     | new        | var        |\n| catch    | finally  | return     | void       |\n| continue | for      | switch     | while      |\n| debugger | function | this       | with       |\n| default  | if       | throw      | delete     |\n| in       | try      |\n\nECMA-262还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们是有可能在将来被用作关键字。以下是ECMA-262第三版定义的全部保留字：\n\n| abstract  |   enum  |   int | short|\n| --------   | -----  | ----- | -------- |\n| boolean | export  | interface |   static|\n| byte    | extends | long  |   super|\n| char    | final   | native  | synchronized|\n| class   | float   | package | throws|\n| const   | goto    | private | transient|\n| debugger |    implements  | protected   | volatile|\n| double  | import  | public  |\n\n\n# 变量：\nECMAScript的变量是松散类型的，所谓松散类型就是可以保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。如：\n\n```javascript\nvar massage;\n```\n\n代码定义了一个名为massage的变量，该变量可以用于保存任何值，未经初始化的变量会保存一个特殊值，即undefined。\n\n在函数中使用var定义变量，在函数退出后就会被销毁，举例：\n\n```javascript\nfunction hello () {\n    var massage = \"hi\";\n}\n\nhello();\nconsole.log(massage); // 错误\n```\n\n一条语句可以定义多个变量，举例：\n\n```javascript\nvar massage  = \"hi\",\n    found = false,\n    age = 29;\n```\n\n# 数据类型：\nECMAScript中有5种简单数据类型：Undefined、Null、Boolean、Number和String，一种复杂类型Object，Object本质是由一组无序的名值对组成的。\n\n## typeof操作符：\ntypeof可能返回的字符串：\n\n* \"undefined\"——如果这个值未定义；\n\n* \"boolean\"——如果这个值是布尔值；\n\n* \"string\"——如果这个值是字符串；\n\n* \"number\"——如果这个值是数值；\n\n* \"object\"——如果这个值是对象或null；\n\n* \"function\"——如果这个值是函数；\n\n```javascript\nvar massage  = \"hi\";\nalert(typeof massage); // \"string\"\nalert(typeof(massage)); // \"string\"\nalert(typeof 95)； // \"number\"\nalert(typeof null); // \"object\", 因为特殊值null被认为是一个空的对象引用\n```\n## undefined类型：\n变量声明但未初始化的，数值为undefined，未声明的变量的typeof也是undefined，举例：\n\n```javascript\nvar massage;\n\n// 该变量未声明\n// var age;\n\nalert(massage);  // \"undefined\"\nalert(age); // 报错\n\nalert(typeof message); // \"undefined\"\nalert(typeof age); // \"undefined\"\n```\n## Null类型：\nNull是只有一个值的数据类型。这个数值为null。<font color=#FF0000 >**从逻辑角度看，null值表示一个对象空指针，这也是使用typeof操作检测null值会返回object的原因，**</font>举例：\n\n```javascript\nvar car = null;\nalert(typeof car); // \"object\"\n```\n\n如果定义变量准备将来用于<font color=#FF0000 >**保存对象，最好初始化为null**</font>而不是其他值，这样，直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，举例：\n\n```javascript\nvar car = null;\nif (car != null) {\n    // 对car的操作\n}\n```\n\n实际上undefined值派生自null值，因此ECMA-262规定对他们的相等性测试要返回true，举例：\n\n```javascript\nalert(null == undefined); // true\n```\n\n只要意在保存对象的变量还没有真正保存对象，就应该明确的让该变量保存null值，这样做不仅可以体现null作为空对象指针的惯例，而且也有助于进一步区分null和undefined。\n\n## Boolean类型：\nBoolean类型有两个字面值，即true和false。这两个值与数字值不是一回事，因此<font color=#FF0000 >**true不一定等于1，false不一定等于0。**</font>true和false区分大小写，因此True和False都不是Boolean值，只是标识符。\n\nECMAScript中<font color=#FF0000 >**所有类型的值都可以通过Boolean()转型函数得到对应的布尔值，**</font>具体是true还是false，请见表：\n\n| 数据类型  |  转换为true的值 |  转换为false的值 | \n| :--------:   | :-----:  | :-----: |\n| String  | 任何非空字符串 | \"\"(空字符串) | \n| Number  | 任何非0数字（包括无穷大） |   0和NaN | \n| Object  | 任何对象  |   null | \n| Undefined |    |     undefined |\n\n\n在执行流程控制语句时，语句会自动执行相应的Boolean转换，举例：\n\n```javascript\nvar massage = \"hello\";\nif (massage) {\n    alert(\"Value is true\");\n}\n```\n\nmassage被自动转换成了Boolean值，这里massage转换为true。\n\n## Number类型：\nNumber可以表示整数和浮点小数，数值的字面量可以是十进制、八进制、十六进制。其中八进制字面值的第一位必须是0，然后八进制数字序列(0~7)。<font color=#FF0000 >**如果数值超出了范围，那么前导零将会被忽略，后面的数值将会被当做十进制数值解析。**</font>十六进制字面值的前两位必须是0x，后面跟任何十六进制数字（0~9即A~F）。其中字母A~F可以大写，也可以小写，举例：\n\n```javascript\n// 十进制数\nvar intNum = 55;\n\n// 八进制数\nvar octalNum1 = 070; // 八进制的56\nvar octalNum2 = 079; // 无效的八进制数值——解析为十进制79\n\n// 十六进制\nvar hexNum1 = 0xA; // 十六进制10\nvar hexNum2 = 0x1f; // 十六进制31\n```\n\n### 浮点小数：\n浮点小数值的数值中必须要包含一个小数点，并且小数点后面至少要有一位数字，举例：\n\n```javascript\nvar floatNum1 = 0.1;\nvar floatNum2 = .1; // 不推荐\n```\n\n由于保存浮点小数内存空间是保存整数的两倍，因此ECMAScript会把小数点中没有跟任何数字的数值作为整数来保存，举例：\n\n```javascript\nvar floatNum1 = 1.; // 解析为整数1\nvar floatNum2 = 10.0; // 解析为整数10\n```\n\n可以用科学计数法表示浮点值，表示方法为前面是一个数值，中间是一个大写或小写的字母E，后面是10的幂中的指数，该幂值将用来与前面的数相乘。举例：\n\nvar floatNum = 3.125e7; // 等于31250000\n浮点小数最高精度是17位小数，但是在进行算术计算时其精度远远不如整数。例如0.1+0.2的结果不是0.3，而是0.30000000000000004，这个<font color=#FF0000 >**小小的舍入误差会导致无法预测特定的浮点小数值，**</font>例如：\n\n```javascript\nif (a + b == 0.3) { // 这里会是false\n    alert(\"you got 0.3!\")\n}\n```\n\n### NaN：\nNaN，即非数值(Not a Number)是一个特殊的数值，这个数值应用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会刨除错误了）。<font color=#FF0000 >**在ECMAScript中，任何数值除以非数值会返回NaN，**</font>因此不会影响其他代码执行。\n\nNaN有两个 不同寻常的特点。<font color=#FF0000 >**首先，任何涉及NaN的操作（如：NaN/10）都会返回NaN，这个特点会在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括本身，**</font>例如：\n\n```javascript\nconsole.log(NaN == NaN); // false\n```\n\n针对NaN这两个特单，ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值后，会尝试将这个值转换为数值。<font color=#FF0000 >**某些不是数值的值会直接转换为数值，例如字符串\"10\"或Boolean值。而任何不能转换为数值的值都会导致这个函数返回true**</font>。举例：\n\n```javascript\nconsole.log(isNaN(NaN));    // true\nconsole.log(isNaN(10));     // false (10是一个数值)\nconsole.log(isNaN(\"10\"));   // false (被转换为数值10)\nconsole.log(isNaN(\"blue\")); // true  (不能被转换成数值)\nconsole.log(isNaN(true));   // false (可以被转换为数值1)\n```\n\n## 数值转换：\n有三个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()。第一个函数即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换为数值。这三个函数对于同样的输入会有返回不同的结果。\n\nNumber()函数的转换规则如下：\n\n+ 如果是Boolean值，true和false分别转换为1和0\n+ 如果是数字值，只是简单的传入和返回 \n+ <font color=#FF0000 >**如果是null值，返回0**</font>\n+ 如果是undefined，返回NaN\n+ 如果是字符串，遵循下列规则：\n    - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即\"1\"会变为1，\"123\"会变为123，<font color=#FF0000 >**而\"011\"会变为11（注意：前导0被忽略了！）**</font>\n    - 如果字符串包含有效的浮点格式，如\"1.1\"，则将其转换为对应的浮点数值（同样会忽略前导0）\n    - <font color=#FF0000 >**如果字符串中只包含有效的十六进制格式，例如\"0xf\"，则将其转换为相同大小的十进制整数**</font>\n    - 如果字符串是空的（不包含任何字符），则将其转换为0\n    - <font color=#FF0000 >**如果字符串包含除以上格式外的字符，则会将其转化为NaN**</font>\n    - 如果是对象，则调用对象的valueOf()方法，然后依次按照前面的规则转换返回的值。如果返回的结果是NaN,则调用toString()方法，然后再次依照前面的规则转换返回的字符串值。举例：\n\n```javascript\nvar num1 = Number(\"hello\");     // NaN 因为不包含任何有意义的数值\nvar num2 = Number(\"\");          // 0\nvar num3 = Number(\"000011\");    // 11\nvar num4 = Number(true);        // 1\n```\n\nNumber()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的parseInt()函数parseInt()函数在转换字符串时，更多的是看其是否符合数值的模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者符号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN(Number会返回0)。如果第一个字符串是数字字符，parseInt会解析第二个字符，知道解析完所有后续字符或者遇到了一个非数字字符。例如，\"123Blue\"会被转换为1234，因为\"Blue\"会被完全忽略。类似地，\"22.5\"会被转换为22，因为小数点并不是有效的数字字符。\n\n如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制、十六进制数）。也就是说，如果字符串以\"0x\"开头且后面跟数字字符，就会当做十六进制整数；如果是以\"0\"开头且后面跟随的是数字字符，将会用八进制数来解析。举例：\n\n```javascript\nvar num1 = parseInt(\"123blue\"); // 123\nvar num2 = parseInt(\"\");        // NaN\nvar num3 = parseInt(\"0xA\");     // 10\nvar num4 = parseInt(22.5);      // 22\nvar num5 = parseInt(\"0xf\");     // 15\nvar num6 = parseInt(\"070\");     // 56\nvar num7 = parseInt(\"70\");      // 70\n```\n\n其中num5存在歧义，在ECMAScript3 JavaScript引擎中会转为56，ECMAScript5 JavaScript引擎中会忽略前导0，转为70，<font color=#FF0000 >**因为ECMAScript5 JavaScript引擎中parseInt()已不具有解析八进制的能力，即使在严格模式下也是不可以的。**</font>为了解决这一问题，parseInt()引入了第二个参数：转换时使用的基数(即多少进制)，举例：\n\n```javascript\nvar num1 = parseInt(\"0xAF\", 16); // 175\nvar num2 = parseInt(\"AF\", 16);   // 175\nvar num3 = parseInt(\"AF\");       // NaN 因为没有数字字符\n\nvar num4 = parseInt(\"10\", 2);    // 2\nvar num5 = parseInt(\"10\", 8);    // 8\nvar num6 = parseInt(\"10\", 10);   // 10\nvar num7 = parseInt(\"10\", 16);   // 16\n```\n\nparseFloat与parseInt类似，<font color=#FF0000 >**区别在于**</font>：\n\n* parseFloat只解析十进制数\n\n* parseFloat会忽略前导0\n\n* 如果被解析的是整数，则函数会返回整数结果\n\n举例：\n\n```javascript\nvar num1 = parseFloat(\"123blue\");   // 123\nvar num2 = parseFloat(\"0xA\");       // 0\nvar num3 = parseFloat(\"22.5\");      // 22.5\nvar num4 = parseFloat(\"22.34.5\");   // 22.34\nvar num5 = parseFloat(\"0908.5\");    // 908.5\nvar num6 = parseFloat(\"3.125e7\");   // 31250000\n```\n\n\n## String类型：\n### 字符串特点：\n字符串是不可变的，也就是说字符串一旦被创建，他们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再另一个包含新值的字符串填充该变量，举例：\n\n```javascript\nvar lang = \"Java\";\nlang = lang + \"Script\";\n```\n\n<font color=#FF0000 >**这个过程包含三步，首先创建一个可以容纳10个字符的新字符串，然后在这个字符串中填充\"Java\"和\"Script\"，最后是销毁原来的字符串\"Java\"和字符串\"Script\"，因为这两个字符串已经没用了。**</font>\n\n### 转换为字符串：\n数值、布尔值、对象和字符串值(返回副本)都有toString()方法，默认情况下返回十进制，如果有其他进制需求，传参即可实现，举例：\n\n## Object类型：\nObject类型是多有他的实例的基础，换计划说，Object所具有的任何属性和方法也同样存在于更具体的对象中。Object类型每个实例都具有下列属性和方法。\n\n* constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数(constructor)就是object()\n\n* hasOwnProperty(propertyName)：用于检查给定的属性在房前对象实例中是否存在。其中作为参数的属性名(propertyName)必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")）\n\n* isPrototypeOf(Object):用于检查传入的对象是否是当前对象的原型\n\n* propertyIsEnumerable(propertyName)：用于检验给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须义字符串子形式指定\n\n* toLocalString()：返回对象的字符串表示，该字符串与执行的环境和地区对应(???)\n\n* toString()：返回对象的字符串表示。\n\n* valueOf()：返回对象的字符串、数值或者布尔值表示，通常与toString()方法返回值相同\n\n# 操作符\n## 一元操作符\n### 递增和递减操作符\n递增操作顾名思义，即给变量加1。操作时在变量前或变量后添加递增符号(++)，放在变量前的操作叫前置递增，放在变量后的操作叫后置递增。递减操作与递增操作相同，为变量减一，符号为(--)。前置递增(递减)，后置递增(递减)二者的区别在于，执行前置递增(递减)操作时，变量的值都是在语句被求值以前改变，而后置递增(递减)操作时是在包含他们的语句被求值后才执行的。举例：\n\n```javascript\nvar num1 = 2;\nvar num2 = 20;\nvar num3 = num1-- + num2; // 22 num3 = 2 + 20，求解完成后，num1减1为1\nvar num4 = num1++ + num2; // 21 num4 = 1 + 20，求解完成后，num1加1为2\nconsole.log(num1);        // 2\n\n\nvar age = 29;\nvar anotherAge1 = --age + 2; // 30, anotherAge1 = 28 + 2\nvar anotherAge2 = ++age + 2; // 31, anotherAge2 = 29 + 2\nconsole.log(age);            // 29\n```\n\n递增和递减操作符不仅仅适用于整数，还适用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作遵循以下规则：\n* 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字符串变量变成数值变量。\n* 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN，字符串变量变成数值变量。\n* 在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变成数值变量。\n* 在应用于布尔值true时，先将其转换为0再执行加减1的操作。布尔值变成数值变量。\n* 在应用于浮点数值时，执行加减1的操作。\n* 在应用于对象时，先调用对象的valueOf()方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规则。对象变量变成数值变量。\n\n举例：\n```javascript\nvar s1 = \"2\";\nvar s2 = \"z\";\nvar b = false;\nvar f = 1.1;\nvar o = {\n    valueOf: function() {\n        return -1;\n    }\n};\n\ns1++; // 数值3\ns2++; // NaN\nb++;  // 数值1\nf--;  // 数值0.10000000000000009(浮点舍入错误所致)\no--;  // 数值2\n```\n\n### 加减操作符\n一元加操作符以一个加号(+)放在数值前边，对数值并不有会任何影响。布尔值ture会转换为1，false转换为0。字符串值会被特殊解析，对象是先调用valueOf()和(或)toString()方法，再转换得到的值。举例：\n\n```javascript\nvar s1 = \"01\";\nvar s2 = \"1.1\";\nvar s3 = \"z\";\nvar b = false;\nvar f = 1.1;\nvar o = {\n    valueOf: function {\n        return -1;\n    }\n};\n\ns1 = +s1; // 数值1\ns2 = +s2; // 数值1.1\ns3 = +s3; // 数值NaN\nb = +b; // 数值0\nf = +f; // 数值1.1\no = +o; // 数值-1\n```\n\n一元减操作符以一个号(-)放在数值前边，与一元加操作不同的是，对于数值，此操作会将原数变为负数。对于应用于非数值时，操作同一元加操作符，最后将数值转换为负数，举例：\n\n```javascript\nvar s1 = \"01\";\nvar s2 = \"1.1\";\nvar s3 = \"z\";\nvar b = false;\nvar f = 1.1;\nvar o = {\n    valueOf: function {\n        return -1;\n    }\n};\n\ns1 = -s1; // 数值-1\ns2 = -s2; // 数值-1.1\ns3 = -s3; // 数值NaN\nb = -b; // 数值0\nf = -f; // 数值-1.1\no = -o; // 数值1\n```\n\n## 位操作符\n位操作符用于在基本的层次上，即按内存中表示数值的位来操作数值。<font color=#FF0000 >**位操作符不直接操作64位值，而是将64位的数值转为32位的整数，然后执行操作，最后再换回64位。对于有符号数，32位中的前31位用于表示整数的值。第32位表示数值符号，0表示正数，1表示负数。这个表示符号的位叫符号位。**</font>举例：数值18，二进制表示为0000 0000 0000 0000 0000 0000 0001 0010(32位表示)。负数同样以二进制存储，但是使用的格式是二进制补码。举例：数值-18，二进制表示1111 1111 1111 1111 1111 1111 1110 1110，但是输出的时候，ECMAScript会隐藏求值的过程信息，表示负数的时候就是在负数的绝对值二进制码前加一个负号，举例：\n\n```javascript\nvar num = -18;\nalert(num.toString(2)); // \"-10010\"\n```\n\n如果对非数值应用操作符，会先使用Number()函数将该值转换为一个数值(自动完成)，然后再应用位操作。得到的结果将是一个数值。\n\n### 按位非（NOT）\n按位非操作符由一个波浪线(~)表示，执行按位非的结果就是返回数值的反码，举例：\n\n```javascript\nvar num1 = 25; // 0000 0000 0000 0000 0000 0000 0001 1001\nvar num2 = ~num2; // 1111 1111 1111 1111 1111 1111 1110 0110\nalert(num2); // \"-26\" 有符号数，第一位不变，取反加1\n```\n\n## 语句\n平时用到的语句不再重复总结，主要总结新认识的语句。\n### for 循环语句\n平时的用法不再赘述，主要说一下for循环的两个特殊例子，首先是无限循环：\n```javascript\nfor (;;) {\n    doSomething();\n}\n```\n第二个例子，for循环转换成while的用法，举例：\n```javascript\nvar count = 10;\nvar i = 0;\nfor (; i < count; ) {\n    alert(i);\n    i++\n}\n```\n\n### for-in 语句\nfor-in 语句是一种精准的迭代语句，<font color=#FF0000 >**可以用来枚举对象属性。</font>，句子语法为 for (property in expression) statement，举例：\n```javascript\nlet a = {\n    b: 1,\n    c: 2\n};\n\nfor (let key in a) {\n    console.log(key);\n    console.log(a[key]);\n}\n\n// b\n// 1\n// c\n// 2\n```\n\n### break 和 continue 语句\nbreak是直接终止全部循环，continue是本次循环终止，继续下一次循环，举例：\n```javascript\nvar num = 0;\nfor (var i = 0; i < 10; i++) {\n    if (i % 5 == 0) {\n        break;\n    }\n    nuum++;\n}\n\nconsole.log(num); // 4\n\nvar num = 0;\nfor (var i = 0; i < 10; i++) {\n    if (i % 5 == 0) {\n        continue;\n    }\n    nuum++;\n}\n\nconsole.log(num); // 8\n```\n\n### with语句\n<font color=#FF0000 >**with语句的作用是将代码的作用于设定到一个特定的对象。</font>语法如下：with (expression) statement;\n举例：\n```javascript\nvar qs = location.search.subtring(1);\nvar hostName = location.hostname;\nvar url = location.href;\n\n// 上述表达式用with语句表示为\nwith (location) {\n    var qs = search.subtring(1);\n    var hostName = hostname;\n    var url = href;\n}\n```\nwith关联了location对象，每个变量首先认为是一个局部变量，如果局部变量找不到则查询location对象中是否有同名属性，如果有则赋值。严格模式下不允许使用with语句。\n\n## 函数\n函数这个部分，主要想重点说一下arguments参数，该参数与数组类似，举例：\n```javascript\nfunction sayHi(num1, num2) {\n    // arguments[0] num1\n    // arguments[1] num2\n    alert(\"hello\" + arguments[0] + ',' + arguments[1]);\n}\n```\n通过访问对象arguments的length属性，可以知道一共传递了多少参数，举例：\n```javascript\nfunction sayHi() {\n    alert(arguments.length);\n}\nsayHi(\"string\", 45); //2\nsayHi(); // 0\nsayHi(1); // 0\n```\n其次就是函数没有重载，举例：\n```javascript\nfunction add(num) {\n    return num + 100;\n}\n\nfunction add(num) {\n    return num + 200;\n}\n\nlet result = add(100); // 300\n```\n一个函数声明了两次，最后一次声明覆盖可之前的声明。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["前端日记","基础日记"]},{"title":"[前端日记][基础日记] script 元素","url":"/2019/09/25/前端日记-基础日记-script-元素/","content":"# script 标签属性：\n* async：可选。表示应该立即下载脚本，但不妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。<font color=#FF0000 >**只对外部文件有效。**</font>\n* charset：可选。表示通过src属性指定的代码字符集。由于大多数浏览器会忽略它的值，因此这个属性很少有人用。\n* defer：可选 。表示脚本可以延迟到文档完全被解析和显示之后再执行。<font color=#FF0000 >**只对外部脚本文件有效。**</font>IE7及更早版本对嵌入脚本也支持这个属性。\n* src：可选。表示包含要执行代码的外部文件。\n* type：可选。可以看成是language的替代属性（该属性已废弃）；表示编写代码使用脚本语言的内容类型（也成为MIME类型）。虽然text/javascript和text/ecmascript都已经不被推荐使用，但人们一直以来使用的都还是text/javascript。实际上，服务器在传送JavaScript文件时使用的MIME类型通常是application/x-javascript。但在type中 设置这个值可能导致脚本被忽略。另外，在非ie浏览器中还可以使用以下值：application/javascript和application/ecmascript。考虑到约定俗成和最大限度的浏览器兼容性，目前type属性的值依旧还是text/javascript。不过，这个属性值并不是必需的，如果没有指定这个属性，则默认值仍为text/javascript。\n\n带有src属性的&lt;script&gt;元素不应该在其&lt;script&gt;和&lt;/script&gt;标签之间再包含额外的JavaScript代码。如果包含了嵌入代码的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。\n\n通过&lt;script&gt;元素的src属性还可以包含来自外部域的JavaScript文件。这一点上，&lt;script&gt;和&lt;img&gt;元素非常相似，即它的src属性可以是指向当前HTML页面所在区域之外的某个域中的完整URL，例如：\n```javascript\n<script type=\"text/javascript\" src=\"http://www.somwhere.com/javascript.js\"></script>\n```\n\n<font color=#FF0000 >**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用这一点就可以在必要时通过不同的域来提供JavaScript文件（利用这一点可以解决前端中的跨域问题）。无论如何包含代码，只要不存在defer和async属性，浏览器都会按照&lt;script&gt;元素所在页面中的先后顺序对它们依次解析。完成第一个&lt;script&gt;标签解析后，才会解析第二个，之后是第三个...**</font>\n\n# 标签位置：\n传统方法是将所有的&lt;script&gt;标签全部放在&lt;head&gt;元素中，例如：\n\n```javascript\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>example html</title>\n        <script type=\"text/javascript\" src=\"example1.js\"></script>\n        <script type=\"text/javascript\" src=\"example2.js\"></script>\n    </head>\n    <body>\n        <!-- 内容 -->\n    </body>\n</html>\n```\n这样做法的目的就是把多有的外部文件包括css文件和JavaScript文件的引用都放在相同的地方。但是放在&lt;head&gt;文件中就意味着<font color=#FF0000 >**必须等到全部文件全部下载完成后才能呈现页面的内容。如果某个文件加载时间过程那么就会导致浏览器出现短暂白屏问题。因此，推荐把标签放置在&lt;body&gt;元素页面内容的后面，**</font>即：\n```javascript\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>example html</title>\n    </head>\n    <body>\n        <!-- 内容 -->\n        <script type=\"text/javascript\" src=\"example1.js\"></script>\n        <script type=\"text/javascript\" src=\"example2.js\"></script>\n    </body>\n</html>\n```\n这样解析包含JavaScript代码之前，页面内容将完全被呈现在浏览器中，而用户也会因为浏览器窗口显示空白页面的时间缩短而感受到页面加载速度变快了（简直是骗人！）。\n\n# 延迟脚本：\nHTML 4.01为&lt;script&gt;标签定义了defer属性。这个属性的用途是表明脚本在执行时不影响页面构造。也就是说脚本会被延迟到整个页面都解析完成后再运行，因此defer属性是告诉浏览器立即下载，但延迟执行。\n```javascript\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>example html</title>\n    </head>\n    <body>\n        <!-- 内容 -->\n        <script type=\"text/javascript\" defer=\"defer\" src=\"example1.js\"></script>\n        <script type=\"text/javascript\" defer=\"defer\" src=\"example2.js\"></script>\n    </body>\n</html>\n```\n上述程序中，脚本将延迟到浏览器遇到&lt;/html&gt;标签后再执行。<font color=#FF0000 >**HTML5规范要求脚本按照他们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoad事件执行。**</font>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在DOMContentLoad事件出发前执行，因此最好只包含一个延迟脚本。因为defer属性只适用于外部脚本文件，因此支持HTML5的实现会忽略给嵌入脚本设置的defer属性。IE4~IE7还支持嵌入脚本的defer属性，但是IE8及之后版本则完全支持HTML5规定的行为。\n\n# 异步脚本：\nHTML5为&lt;script&gt;元素定义了async属性。这个属性与defer属性类似，都用于改变处理脚本的行为。同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但是与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行，例如：\n```javascript\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>example html</title>\n    </head>\n    <body>\n        <!-- 内容 -->\n        <script type=\"text/javascript\" async src=\"example1.js\"></script>\n        <script type=\"text/javascript\" async src=\"example2.js\"></script>\n    </body>\n</html>\n```\n上述代码中，第二个脚本文件可能会在第一个脚本文件之前执行。因此，确保两者互不依赖非常重要。异步脚本一定会在页面load事件前之心，但是可能会在DOMContentLoad事件触发之前或者之后执行。\n\n# 外部文件引入的优势：\n可维护性：遍及不同HTML页面的JavaScript会造成维护问题。但是把所有的JavaScript文件都放在一个文件夹中，维护起来就轻松多了。\n\n可缓存：浏览器能够根据具体的设置缓存链接的所有外部JavaScript文件。也就是说，如果有两个页面都使用了同一个文件，那么这个文件只需要下载一次。因此，最终结果就是能够加快页面加载的速度。\n\n参考文献：JavaScript高级语言设计","tags":["前端日记","基础日记"]},{"title":"[前端日记[ES6日记] let 和const命令","url":"/2019/09/25/前端日记-ES6日记-let-和const命令/","content":"# let命令\n## 基本用法\nes6新增了let命令，用于变量声明。其用法类似于var。但是所声明的**变量只在代码块中有效**。举例：\n```javascript\n    {\n        let a = 10;\n        var b = 20;\n    }\n    console.log(a); //ReferenceError: a is not definde.\n    console.log(b); // 20\n```\n**补充例子**\n### 不存在变量提升\n**var会存在变量提升现象，变量可以在未声明之前使用，而let为了纠正这个问题，要求必须先声明再使用，在声明前使用会报错**，举例：\n```javascript\n    // var的情况\n    console.log(foo); // 输出undefined\n    var foo = 2;\n    \n    // let的情况\n    console.log(bar); // 报错 ReferenceError\n    let bar = 2;\n```\n### 暂时性死区\n只要在作用于内存在let命令，他的所有声明变量及时绑定在这个区域的，不再受外部影响，举例：\n```javascript\n    var temp = 123;\n    if (true) {\n        tmp = 'abc'; // 报错 ReferenceError\n        let tmp;\n    }\n```\n报错原因是在区域内有let声明了变量，但是使用却在声明之前，因此赋值会报错。在这种情况下typeof也不是完全安全的操作，举例：\n```javascript\n    typeof tmp; // 报错 ReferenceError\n    let tmp = 123;\n\n    typeof undefinedVar; // undefined\n```\n对于一个没有声明的变量，typeof是不会报错的。\n有些隐蔽死区，也是容易出错的地方，举例：\n```javascript\n    function bar(x = y, y = 2) {\n        return [x, y];\n    }\n    \n    bar(); // 报错\n```\n函数报错原因在于x等于变量y，但是y在此时没有声明。如果更改一下位置即可，y在使用x的时候，x已经声明过了，不会报错同时\n```javascript\n    function bar(x = 2, y = x) {\n        return [x, y];\n    }\n    \n    bar();\n```\n### 不允许出现重复声明\nlet 不允许相同的变量在同一个作用域内重复说明，举例：\n```javascript\n    // 报错\n    function bar() {\n        let a = 10;\n        var a = 10;\n    }\n    \n    // 报错\n    function bar() {\n        let a = 10;\n        let a = 10;\n    }\n\n    // 报错\n    function bar(arg) {\n        let arg = 10;\n    }\n\n    // 不报错\n    function bar(arg) {\n        {\n            let arg = 10;\n        }\n    }\n```\n## 块级作用域\n块级作用域的出现主要解决两个问题，第一个是内层变量可能覆盖外层变量，第二个是，用来计数的循环变量泄露为全局变量。举例：\n```javascript\n    // 变量覆盖\n    var tmp = new Date();\n    function f() {\n        console.log(tmp);\n        if (false) {\n            var tem = \"hello\";\n        }\n    }\n    f(); // undefined 原因在于 if内的var变量提升,覆盖了外边的tmp，所以打印为undefined\n    \n    // 计数循环变量为全局变量\n    s = \"hello\";\n    for (var i = 0; i < s.length; i++) {\n        console.log(s[i]);\n    } \n    console.log(i); // 5 循环结束后没有被销毁，泄露为全局变量\n```\n### ES6的块级作用域\n```javascript\n    function f() {\n        let n = 5;\n        if (true) {\n            let n = 10;\n        }\n        console.log(n); // 5\n    }\n```\nes6在块级作用域中，函数声明也会存在变量提升的处理，举例：\n```javascript\n    // 下面函数会报错 Uncaught TypeError: f is not a function\n    function f() {  \n        console.log(\"I am outside!\");\n    }\n    \n    (function () {\n        if (false) {\n            function f () {\n                console.log(\"I am inside!\");\n            }\n        }\n        f();\n    })();\n    \n    // 原因为\n    function f() {  \n        console.log(\"I am outside!\");\n    }\n    \n    (function () {\n        var function f = undefined; // 函数声明提升\n        if (false) {\n            function f () {\n                console.log(\"I am inside!\");\n            }\n        }\n        f(); // Uncaught TypeError: f is not a function\n    })();\n```\n# const命令\n## 基本用法\nconst声明一个只读常量，一旦声明不能改变。\n```javascript\n    const PI = 3.14;\n    PI = 3; // 报错\n```\n声明必须初始化，不然报错，举例：\n```javascript\n    const PI; // 报错\n```\n同样const在块级作用域有效，也不存在变量提升，同样不能重复定义，举例：\n```javascript\n    // 块级作用域有效\n    if (true) {\n        const PI = 3.14;\n    }\n    PI // 报错\n    \n    // 不存在变量提升\n    if (true) {\n        console.log(PI); // 报错，事前用没有声明\n        const PI = 3.14;\n    }\n    \n    // 不可重复定义\n    var massage = \"hello\";\n    let age = 10;\n    // 下面两句报错\n    const massage = \"hello\";\n    const age = 10;\n```\n### 本质\n**const实际上保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动，** 对于简单的数据类型（如：数值、布尔、字符串）而言，变量指向的内存地址保存的只是一个指针，const能够保证这个指针是固定的，至于它指向的数据结构是不是可变的，这是完全不能控制的，因此，将一个对象声明为常量的时候要小心。举例：\n```javascript\n    const foo = {}\n    \n    // 为foo添加属性\n    foo.prop = 123; // 不报错\n    foo.prop; // 123\n\n    const a = [];\n    a.push(\"hello\"); // 可执行\n    a.length; // 可执行\n    a = ['word']; // 报错\n```\n如果想将对象冻结，应该使用Object.freeze方法。\n```javascript\n    const foo = Object.freeze({});\n    \n    // 常规模式下，不起作用，严格模式下报错\n    foo.prop = 123;\n```","tags":["前端日记","ES6日记"]},{"title":"golang 安装","url":"/2017/08/30/golang-安装/","content":"# MAC安装Go\n\n使用go之前的环境配置\n\n### 1.安装Homebrew\n\n请参照Homebrew官网安装: [点击访问Homebrew主页](https://brew.sh/)\n\n### 2.安装Golang\n\n``` bash\n$ brew install go\n```\n\n### 3.配置GOPATH\n\n``` bash\n$ go env\n```\n\n``` bash\n$ set -gx GOPATH /usr/local/Cellar/go/1.7.6\n```\n\n在bash中设置\n\n``` bash\n$ vim .bash_profile\n\n    export GOPATH=/usr/local/Cellar/go/1.7.6\n    export GOBIN=$GOPATH/bin\n    export PATH=$PATH:$GOBIN\n```\n\n使修改立刻生效:\n\n``` bash\n$ source .bash_profile\n```\n\n参考链接: http://www.jianshu.com/p/358cbc939569","tags":["golang","mac"]},{"title":"Hello World","url":"/2017/07/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]
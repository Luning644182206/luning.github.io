[{"title":"[前端日记[ES6日记] let 和const命令","url":"/2019/09/25/前端日记-ES6日记-let-和const命令/","content":"# let命令\n## 基本用法\nes6新增了let命令，用于变量声明。其用法类似于var。但是所声明的**变量只在代码块中有效**。举例：\n```javascript\n    {\n        let a = 10;\n        var b = 20;\n    }\n    console.log(a); //ReferenceError: a is not definde.\n    console.log(b); // 20\n```\n**补充例子**\n### 不存在变量提升\n**var会存在变量提升现象，变量可以在未声明之前使用，而let为了纠正这个问题，要求必须先声明再使用，在声明前使用会报错**，举例：\n```javascript\n    // var的情况\n    console.log(foo); // 输出undefined\n    var foo = 2;\n    \n    // let的情况\n    console.log(bar); // 报错 ReferenceError\n    let bar = 2;\n```\n### 暂时性死区\n只要在作用于内存在let命令，他的所有声明变量及时绑定在这个区域的，不再受外部影响，举例：\n```javascript\n    var temp = 123;\n    if (true) {\n        tmp = 'abc'; // 报错 ReferenceError\n        let tmp;\n    }\n```\n报错原因是在区域内有let声明了变量，但是使用却在声明之前，因此赋值会报错。在这种情况下typeof也不是完全安全的操作，举例：\n```javascript\n    typeof tmp; // 报错 ReferenceError\n    let tmp = 123;\n\n    typeof undefinedVar; // undefined\n```\n对于一个没有声明的变量，typeof是不会报错的。\n有些隐蔽死区，也是容易出错的地方，举例：\n```javascript\n    function bar(x = y, y = 2) {\n        return [x, y];\n    }\n    \n    bar(); // 报错\n```\n函数报错原因在于x等于变量y，但是y在此时没有声明。如果更改一下位置即可，y在使用x的时候，x已经声明过了，不会报错同时\n```javascript\n    function bar(x = 2, y = x) {\n        return [x, y];\n    }\n    \n    bar();\n```\n### 不允许出现重复声明\nlet 不允许相同的变量在同一个作用域内重复说明，举例：\n```javascript\n    // 报错\n    function bar() {\n        let a = 10;\n        var a = 10;\n    }\n    \n    // 报错\n    function bar() {\n        let a = 10;\n        let a = 10;\n    }\n\n    // 报错\n    function bar(arg) {\n        let arg = 10;\n    }\n\n    // 不报错\n    function bar(arg) {\n        {\n            let arg = 10;\n        }\n    }\n```\n## 块级作用域\n块级作用域的出现主要解决两个问题，第一个是内层变量可能覆盖外层变量，第二个是，用来计数的循环变量泄露为全局变量。举例：\n```javascript\n    // 变量覆盖\n    var tmp = new Date();\n    function f() {\n        console.log(tmp);\n        if (false) {\n            var tem = \"hello\";\n        }\n    }\n    f(); // undefined 原因在于 if内的var变量提升,覆盖了外边的tmp，所以打印为undefined\n    \n    // 计数循环变量为全局变量\n    s = \"hello\";\n    for (var i = 0; i < s.length; i++) {\n        console.log(s[i]);\n    } \n    console.log(i); // 5 循环结束后没有被销毁，泄露为全局变量\n```\n### ES6的块级作用域\n```javascript\n    function f() {\n        let n = 5;\n        if (true) {\n            let n = 10;\n        }\n        console.log(n); // 5\n    }\n```\nes6在块级作用域中，函数声明也会存在变量提升的处理，举例：\n```javascript\n    // 下面函数会报错 Uncaught TypeError: f is not a function\n    function f() {  \n        console.log(\"I am outside!\");\n    }\n    \n    (function () {\n        if (false) {\n            function f () {\n                console.log(\"I am inside!\");\n            }\n        }\n        f();\n    })();\n    \n    // 原因为\n    function f() {  \n        console.log(\"I am outside!\");\n    }\n    \n    (function () {\n        var function f = undefined; // 函数声明提升\n        if (false) {\n            function f () {\n                console.log(\"I am inside!\");\n            }\n        }\n        f(); // Uncaught TypeError: f is not a function\n    })();\n```\n# const命令\n## 基本用法\nconst声明一个只读常量，一旦声明不能改变。\n```javascript\n    const PI = 3.14;\n    PI = 3; // 报错\n```\n声明必须初始化，不然报错，举例：\n```javascript\n    const PI; // 报错\n```\n同样const在块级作用域有效，也不存在变量提升，同样不能重复定义，举例：\n```javascript\n    // 块级作用域有效\n    if (true) {\n        const PI = 3.14;\n    }\n    PI // 报错\n    \n    // 不存在变量提升\n    if (true) {\n        console.log(PI); // 报错，事前用没有声明\n        const PI = 3.14;\n    }\n    \n    // 不可重复定义\n    var massage = \"hello\";\n    let age = 10;\n    // 下面两句报错\n    const massage = \"hello\";\n    const age = 10;\n```\n### 本质\n**const实际上保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动，** 对于简单的数据类型（如：数值、布尔、字符串）而言，变量指向的内存地址保存的只是一个指针，const能够保证这个指针是固定的，至于它指向的数据结构是不是可变的，这是完全不能控制的，因此，将一个对象声明为常量的时候要小心。举例：\n```javascript\n    const foo = {}\n    \n    // 为foo添加属性\n    foo.prop = 123; // 不报错\n    foo.prop; // 123\n\n    const a = [];\n    a.push(\"hello\"); // 可执行\n    a.length; // 可执行\n    a = ['word']; // 报错\n```\n如果想将对象冻结，应该使用Object.freeze方法。\n```javascript\n    const foo = Object.freeze({});\n    \n    // 常规模式下，不起作用，严格模式下报错\n    foo.prop = 123;\n```","tags":["前端日记","ES6日记"]},{"title":"golang 安装","url":"/2017/08/30/golang-安装/","content":"# MAC安装Go\n\n使用go之前的环境配置\n\n### 1.安装Homebrew\n\n请参照Homebrew官网安装: [点击访问Homebrew主页](https://brew.sh/)\n\n### 2.安装Golang\n\n``` bash\n$ brew install go\n```\n\n### 3.配置GOPATH\n\n``` bash\n$ go env\n```\n\n``` bash\n$ set -gx GOPATH /usr/local/Cellar/go/1.7.6\n```\n\n在bash中设置\n\n``` bash\n$ vim .bash_profile\n\n    export GOPATH=/usr/local/Cellar/go/1.7.6\n    export GOBIN=$GOPATH/bin\n    export PATH=$PATH:$GOBIN\n```\n\n使修改立刻生效:\n\n``` bash\n$ source .bash_profile\n```\n\n参考链接: http://www.jianshu.com/p/358cbc939569","tags":["golang","mac"]},{"title":"Hello World","url":"/2017/07/23/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]